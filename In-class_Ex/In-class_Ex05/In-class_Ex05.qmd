---
title: "In-class Exercise 5: Global and Local Measures of Spatial Autocorrelation: sfdep methods"
author: "Jeffrey Lee Shao Lin"
date: "September 23, 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  freeze: true
  warning: false
---

# 1. Introduction

-   Introducing [**sfdep**](https://sfdep.josiahparry.com/).

-   sfdep creates an sf and tidyverse friendly interface to the package as well as introduces new functionality that is not present in spdep.

-   sfdep utilizes list columns extensively to make this interface possible.”

# 2. Getting started

Four R packages will be used for this in-class exercise, they are: sf, sfdep, tmap and tidyverse.

```{r}
pacman::p_load(sf, sfdep, tmap, tidyverse)
```

# 3. The Data

There are two data sets in this use case, they are:

-   Hunan, a geospatial data set in ESRI shapefile format, and

-   Hunan_2012, an attribute data set in csv format.

```{r}
hunan <- st_read(dsn = "data/geospatial", 
                 layer = "Hunan")
```

# 4. Importing Attribute Table

```{r}
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv")
```

# 5. Combining both data frame by using left join

```{r}
hunan_GDPPC <- left_join(hunan,hunan2012) %>%
  select(1:4, 7, 15)
```

::: callout-note
Note that there are five types of callouts, including: For the purpose of this exercise, we only retain column 1 to 4, column 7 and column 15. You should examine the output sf data.frame to learn know what are these fields.
:::

::: {.callout-warning title="Important"}
In order to retain the geospatial properties, the left data frame must the sf data.frame (i.e. hunan)
:::

# 6. Plotting a choropleth map

Plot a choropleth map showing the distribution of GDPPC of Hunan Province.

```{r}
tmap_mode("plot")
tm_shape(hunan_GDPPC) +
  tm_fill("GDPPC",
          style = "quantile",
          palette = "Blues",
          title = "GDPPC") +
  tm_borders(col = "grey") +
  tm_layout(main.title = "Distribution of GDP per capita by country, Hunan Province",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45,
            legend.width = 0.35,
            frame = TRUE)
```

# 7. Global Measures of Spatial Association

## 7.1 Step 1: Deriving Queen’s contiguity weights: sfdep methods

```{r}
wm_q <- hunan_GDPPC %>%
  mutate(nb = st_contiguity(geometry),
         wt = st_weights(nb,
                         style = "W"),
         .before = 1)
```

Notice that `st_weights()` provides tree arguments, they are:

-   *nb*: A neighbor list object as created by st_neighbors().

-   *style*: Default “W” for row standardized weights. This value can also be “B”, “C”, “U”, “minmax”, and “S”. B is the basic binary coding, W is row standardised (sums over all links to n), C is globally standardised (sums over all links to n), U is equal to C divided by the number of neighbours (sums over all links to unity), while S is the variance-stabilizing coding scheme proposed by Tiefelsdorf et al. 1999, p. 167-168 (sums over all links to n).

-   *allow_zero*: If TRUE, assigns zero as lagged value to zone without neighbors.

```{r}
wm_q
```

## 7.2 Computing Global Moran’ I

In the code chunk below, [`global_moran()`](https://sfdep.josiahparry.com/reference/global_moran) function is used to compute the Moran’s I value. Different from spdep package, the output is a tibble data.frame.

```{r}

moranI <- global_moran(wm_q$GDPPC,
                       wm_q$nb,
                       wm_q$wt)
glimpse(moranI)
```

## 7.3 Performing Global Moran’sI test

In general, Moran’s I test will be performed instead of just computing the Moran’s I statistics. With sfdep package, Moran’s I test can be performed by using [`global_moran_test()`](https://sfdep.josiahparry.com/reference/global_moran_test.html) as shown in the code chunk below.

```{r}

global_moran_test(wm_q$GDPPC,
                  wm_q$nb,
                  wm_q$wt)
```

::: callout-tip
## Tip

-   The default for `alternative` argument is “two.sided”. Other supported arguments are “greater” or “less”. randomization, and

-   By default the `randomization` argument is **TRUE**. If FALSE, under the assumption of normality.
:::

## 7.4 Global Moran’I permutation test

In practice, Monte carlo simulation should be used to perform the statistical test. For sfdep, it is supported by  [`globel_moran_perm()`](https://sfdep.josiahparry.com/reference/global_moran_perm.html)

::: panel-tabset
## Step 1

It is always a good practice to use `set.seed()` before performing simulation. This is to ensure that the computation is reproducible.

```{r}

seed(1234)

```

## Step 2

Next, `global_moran_perm()` is used to perform Monte Carlo simulation.

```{r}

global_moran_perm(wm_q$GDPPC,
                  wm_q$nb,
                  wm_q$wt,
                  nsim = 99)
```

## The report

The statistical report on previous tab shows that the p-value is smaller than alpha value of 0.05. Hence, we have enough statistical evidence to reject the null hypothesis that the spatial distribution of GPD per capita are resemble random distribution (i.e. independent from spatial). Because the Moran’s I statistics is greater than 0. We can infer that the spatial distribution shows sign of clustering.

::: {.callout-tip}
## Reminder

The numbers of simulation is alway equal to nsim + 1. This mean in nsim = 99. This mean 100 simulation will be performed.
:::

:::

```{r}
lisa <- wm_q %>%
  mutate(local_moran = local_moran(
    GDPPC, nb, wt, nsim = 99),
    .before = 1) %>%
  unnest(local_moran)
```

```{r}
tmap_mode("plot")
tm_shape(lisa) +
  tm_fill("ii") +
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(
    main.title = "local Moran's I of GDPPC",
    main.title.size = 2)
```

```{r}
tmap_mode("plot")
tm_shape(lisa) +
  tm_fill("p_ii_sim") +
  tm_borders(alpha = 0.5) +
  tm_layout(
    main.title = "p-values of local Moran's I",
    main.title.size = 2)
```

```{r}
tmap_mode("plot")
map1 <- tm_shape(lisa) + 
  tm_fill("ii")+
  tm_borders(alpha=0.5)+
  tm_layout(main.title="p-value",
            main.title.size=2)

tmap_mode("plot")
map2 <- tm_shape(lisa) + 
  tm_fill("p_ii_sim")+
  tm_borders(alpha=0.5)+
  tm_layout(main.title="p-value",
            main.title.size=2)

tmap_arrange(map1, 
             map2, 
             asp=1, #Aspect Ratio
             ncol=2)
```

```{r}
lisa_sig <- lisa %>%
  filter(p_ii < 0.05) #filter only significant p values

tmap_mode("plot")
tm_shape(lisa)+
  tm_polygons()+
  tm_borders(alpha=0.5)+
tm_shape(lisa_sig)+
  tm_fill("mean")+
  tm_borders(alpha=0.4)

```

```{r}
wm_idw <- hunan_GDPPC %>% 
  mutate(nb = st_contiguity(geometry) ,
         wts = st_inverse_distance(nb, geometry,
                                  scale = 1,
                                  alpha =1),
         .before = 1)
```

```{r}
HCSA <- wm_idw %>% 
  mutate(local_Gi = local_gstar_perm(
    GDPPC, nb, wt, nsim = 99),
    .before = 1) %>% 
  unnest(local_Gi)
HCSA

```

```{r}
tmap_mode("plot")
tm_shape(HCSA)+
  tm_fill("gi_star")+
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8))
```

```{r}

#| eval: false
HCSA_sig <- HCSA %>% 
  filter(p_sim < 0.05)
tmap_mode("plot")
tm_shape(HCSA) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(HCSA_sig) +
  tm_fill("cluster") +
  tm_borders(alpha = 0.4)
```
